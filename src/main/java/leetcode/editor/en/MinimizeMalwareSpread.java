//In a network of nodes, each node i is directly connected to another node j if
//and only if graph[i][j] = 1. 
//
// Some nodes initial are initially infected by malware. Whenever two nodes are 
//directly connected and at least one of those two nodes is infected by malware, b
//oth nodes will be infected by malware. This spread of malware will continue unti
//l no more nodes can be infected in this manner. 
//
// Suppose M(initial) is the final number of nodes infected with malware in the 
//entire network, after the spread of malware stops. 
//
// We will remove one node from the initial list. Return the node that if remove
//d, would minimize M(initial). If multiple nodes could be removed to minimize M(i
//nitial), return such a node with the smallest index. 
//
// Note that if a node was removed from the initial list of infected nodes, it m
//ay still be infected later as a result of the malware spread. 
//
// 
//
// 
// 
//
// Example 1: 
//
// 
//Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
//Output: 0
// 
//
// Example 2: 
//
// 
//Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
//Output: 0
// 
//
// Example 3: 
//
// 
//Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
//Output: 1
// 
//
// 
//
// Note: 
//
// 
// 1 < graph.length = graph[0].length <= 300 
// 0 <= graph[i][j] == graph[j][i] <= 1 
// graph[i][i] = 1 
// 1 <= initial.length < graph.length 
// 0 <= initial[i] < graph.length 
// 
// Related Topics Depth-first Search Union Find


package leetcode.editor.en;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;

public class MinimizeMalwareSpread {
    public static void main(String[] args) {
        Solution solution = new MinimizeMalwareSpread().new Solution();
    }

    //leetcode submit region begin(Prohibit modification and deletion)
    class Pair {
        int infectedCount;
        int totalCount;
        Pair(int infectedCount, int totalCount) {
            this.infectedCount = infectedCount;
            this.totalCount = totalCount;
        }

        Pair combine(Pair that) {
            return new Pair(this.infectedCount + that.infectedCount, this.totalCount + that.totalCount);
        }
    }
    class Solution {
        Set<Integer> visisted = new HashSet<>();
        int totalN;
        int[][] graph;
        Set<Integer> initial;
        public int minMalwareSpread(int[][] graph, int[] initial) {
            totalN = graph.length;
            this.graph = graph;
            this.initial = Arrays.stream(initial).boxed().collect(Collectors.toSet());
            int currentMax = -1;
            int index = -1;
            for (int i : Arrays.stream(initial).sorted().toArray()) {
                if (!visisted.contains(i)) {
                    Pair result = dfs(i);
                    if (result.infectedCount == 1) {
                        if (result.totalCount > currentMax) {
                            currentMax = result.totalCount;
                            index = i;
                        }
                    } else {
                        if (index == -1) {
                            currentMax = 0;
                            index = i;
                        }
                    }
                }
            }
            return index;
        }

        private Pair dfs(int index) {
            visisted.add(index);
            Pair result = new Pair(initial.contains(index) ? 1 : 0, 1);
            for (int i = 0; i < totalN; i++) {
                if (!visisted.contains(i) && graph[index][i] == 1) {
                    result = result.combine(dfs(i));
                }
            }
            return result;
        }
    }
//leetcode submit region end(Prohibit modification and deletion)

}